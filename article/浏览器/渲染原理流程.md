# 浏览器渲染各个阶段流程

@startuml start :加载 HTML; group #d9f7be html 解析阶段 :解析 HTML; :生成 Dom 树; :遇到 css 样式; :阻塞解析 生成 CSSOM 树 (css object module); :script 标签; if (defer or async 属性) then(否) :阻塞解析; :加载 js 代码，并执行; else(是) endif; :img 等资源标签，加载资源; :完成解析，生成 DomTree 和 CSSOM 树; end group group #b5f5ec 构建渲染树阶段(Render Tree) :合并 Dom 树 和 CSSOM 树; :过滤不可见元素（如：display: none），不渲染; :可见性隐藏元素（如：visibility: hidden）会进入渲染树，占据空间; :标注每个 Dom 节点大小、位置、样式信息; :返回 RenderTree; end group; group #bae7ff 布局（Layout） :也叫“重排”，计算每个节点在屏幕上的精确位置大小; :递归渲染树并计算每个Dom节点的几何属性（如宽度、高度、边距等）; end group; group #ffadd2 分层与绘制（Paint） :分层：浏览器将渲染树拆分为多个图层（如视频、Canvas、Z-index 较高的元素），独立处理; :将每个图层的像素信息 记录为绘制命令（如“填充矩形”“绘制文本”），生成 绘制列表; end group; group #d3adf7 光栅化与合成（Raster & Composite） :光栅化: 将绘制命令转换为位图 （像素），由 GPU 加速处理; :合成:将多个图层的位图按顺序叠加，最终显示在屏幕上; note right   示例：   滚动时仅需重新合成可见区域，   无需重新布局或绘制。 end note end group; stop @enduml

### 关键性能优化机制

1.  **回流（Reflow）与重绘（Repaint）**
    
    1.  **回流** ：布局变化（如调整尺寸）触发重新计算几何信息，成本高
        
    2.  **重绘** ：仅样式变化（如颜色）触发像素更新，成本较低
        
    3.  **优化建议** ：批量修改 DOM 或使用 
        
2.   透明度：`opacity` 实现动画，因为不会触发重排和重绘。
    
3.   **异步加载资源**
    

1.  使用 `async` 或 `defer` 属性加载 JavaScript 文件，避免阻塞 HTML 解析。
    
    1.  **async**：属性允许脚本异步加载，下载完成后理解执行但不会保证脚本的执行顺序。
        
    2.  **defer ：**属性允许脚本异步加载，下载完成并确保脚本按照它们在 HTML 中的顺序执行。
        
2.  将 CSS 放在 `<head>` 中，确保尽早开始解析。
    

1.   使用分层（Layering）
    

1.  利用 **GPU 加速** 加速，将动画元素提升到独立的图层： 使用 `transform`。
    
2.  使用 `will-change` 属性提示浏览器提前创建图层。
