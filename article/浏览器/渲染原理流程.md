### 浏览器渲染原理流程图 UML 绘制

@startuml
start
:加载 HTML;
group #d9f7be html 解析阶段
:解析 HTML;
:生成 Dom 树;
:遇到 css 样式;
:阻塞解析 生成 CSSOM 树 (css object module);
:script 标签;
note right
defer：允许脚本异步加载，加载完成后按HTML中顺序执行
无需重新布局或绘制。
async：允许脚本异步加载，加载完成后立即执行不保证顺序。
end note
if (defer or async 属性) then(否)
:阻塞解析;
:加载 js 代码，并执行;
else(是)
endif;
:img 等资源标签，加载资源;
:完成解析，生成 DomTree 和 CSSOM 树;
end group

group #b5f5ec 构建渲染树阶段(Render Tree)
:合并 Dom 树 和 CSSOM 树;
:过滤不可见元素（如：display: none），不渲染;
:可见性隐藏元素（如：visibility: hidden）会进入渲染树，占据空间;
:标注每个 Dom 节点大小、位置、样式信息;
:返回 RenderTree;
end group;

group #bae7ff 布局（Layout）
:也叫“重排”，计算渲染树中每个节点的几何位置和尺寸 
（如 width、height），形成 布局树;
note right
示例：
    确定 div 元素在视口中的坐标
    （x=100px, y=50px）。
关键点:
    布局可能因视口尺寸变化（如移动端旋转）或 DOM 
    动态修改而重新触发（回流）;
end note
end group;

group #ffadd2 分层与绘制（Paint）
:分层：浏览器将渲染树拆分为多个图层（如视频、Canvas、Z-index 较高的元素），独立处理;
:将每个图层的像素信息 记录为绘制命令（如“填充矩形”“绘制文本”），生成 绘制列表;
end group;

group #d3adf7 光栅化与合成（Raster & Composite）
:光栅化: 将绘制命令转换为位图 （像素），由 GPU 加速处理;

:合成:将多个图层的位图按顺序叠加，最终显示在屏幕上;
note right
示例：
滚动时仅需重新合成可见区域，
无需重新布局或绘制。
end note
end group;
stop
@enduml



### 关键性能优化机制
1. 回流（Reflow）与重绘（Repaint）
    a. 回流 ：布局变化（如调整尺寸）触发重新计算几何信息，成本高
    b. 重绘 ：仅样式变化（如颜色）触发像素更新，成本较低
    c. 优化建议 ：批量修改 DOM 或使用 
2.  透明度：opacity 实现动画，因为不会触发重排和重绘。
3.  异步加载资源
    a. 使用 async 或 defer 属性加载 JavaScript 文件，避免阻塞 HTML 解析。
        i. async：属性允许脚本异步加载，下载完成后理解执行但不会保证脚本的执行顺序。
        ii. defer ：属性允许脚本异步加载，下载完成并确保脚本按照它们在 HTML 中的顺序执行。
    b. 将 CSS 放在 <head> 中，确保尽早开始解析。
4.  使用分层（Layering）
    a. 利用 GPU 加速 加速，将动画元素提升到独立的图层： 使用 transform。
    b. 使用 will-change 属性提示浏览器提前创建图层。
